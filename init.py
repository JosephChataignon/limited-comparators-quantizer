#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import numpy as np

import utils
import measures as ms

def normal(nHyperplanes,nDimensions):
    """
        Returns a set of hyperplanes with random orientations. nHyperplanes is
        the number of hyperplanes to return, and nDimension the number of
        dimensions of the space.
        The hyperplanes are simply generated by setting their coordinates to
        random values following a normal distribution.
    """
    return np.random.normal(0,10,(nHyperplanes,nDimensions+1))

def doublePoint(nHyperplanes,nDimensions,distrib):
    """
        Returns a set of hyperplanes with random orientations. nHyperplanes is
        the number of hyperplanes to return, and nDimension the number of
        dimensions of the space.
        Here for each hyperplane, nDimensions random points are generated
        following the distribution distrib, and the unique hyperplane passing 
        by all these points is kept.
    """
    hyperplanes = []
    for k in range(nHyperplanes):
        points = [utils.f(nDimensions,distrib) for n in range(nDimensions)]
        hyperplanes.append( utils.hyperplaneFromPoints(points) )
    return np.array(hyperplanes)

def poolSelect(nHyperplanes, nDimensions, pCentroids, pMeasure, nConfigs, distrib, m,initType='normal'):
    '''
        Initialize hyperplanes by generating a pool of nConfigs random 
        configurations and selecting the one with lowest measure of distortion.
    '''
    for k in range(nConfigs):
        if initType == 'normal':
            hp = normal(nHyperplanes,nDimensions) #can add other initialization functions in elif statements
        else:
            print("ERROR! invalid initialization type")
        e = ms.measure(m,hp,pCentroids,pMeasure,distrib)
        if k == 0:
            minDistortion = e
            minHp = hp
        else:
            if minDistortion >= e:
                minDistortion = e
                minHp = hp
    return minHp









